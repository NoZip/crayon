%{
#include <string>

#include "point.hpp"
#include "path.hpp"

#include "instruction.hpp"
#include "command.hpp"
#include "flow.hpp"

#define YYLEX_PARAM &yylval, &yylloc
%}

%locations

// Types definitions

%union {
    float real;
    bool boolean;
    char* string;
    Point* point;
    Path* path;
    Instruction* instruction;
    Flow* flow;
}

%token <real> REAL
%token <string> NAME

%type <real> expression
//%type <boolean> inequation

%type <point> point
%type <path> path

%type <instruction> instruction
%type <instruction> command
%type <flow> flow


// Operators and separators
%token SEMICOLON
%token RPAR LPAR
%token PLUS MINUS MUL DIV
%token EQUAL NEQUAL GT GTE LT LTE
%token COMMA DOUBLE_DOT
%token PATH_SEPARATOR CYCLE
%token DRAW_COMMAND FILL_COMMAND
%token TRANSLATE_BUILDIN
%token ROTATE_BUILDIN
%token NEWLINE

%left PLUS MINUS
%left MUL DIV
%left UNARY

%{
#define yyerror(Msg) _yyerror(&yylloc, Msg)

void _yyerror(YYLTYPE *yylloc, const char *s) {
    fprintf(stderr, "ERROR %d:%d %s\n", yylloc->first_line, yylloc->first_column, s);
}

extern "C" {
    int yylex(YYSTYPE * yylval_param,YYLTYPE * yylloc_param);
}
%}

%%

image : flow {$1->execute(); delete $1;}
;

flow : flow instruction {$1->append($2);}
| instruction {Flow *f = new Flow(); f->append($1); $$ = f;}
;

instruction : command
;

// Computes mathematical expressions
expression : expression PLUS expression {$$ = $1 + $3;}
| expression MINUS expression {$$ = $1 - $3;}
| MINUS expression %prec UNARY {$$ = -$2;}
| expression MUL expression {$$ = $1 * $3;}
| expression DIV expression {$$ = $1 / $3;}
| REAL {$$ = $1;}
;

/*
inequation : expression EQUAL expression {$$ = ($1 == $3);}
| expression NEQUAL expression {$$ = ($1 != $3);}
| expression GT expression {$$ = ($1 > $3);}
| expression GTE expression {$$ = ($1 >= $3);}
| expression LT expression {$$ = ($1 < $3);}
| expression LTE expression {$$ = ($1 <= $3);}
;
*/

point : RPAR expression COMMA expression LPAR {
    Point *p = new Point($2, $4);
    $$ = p;
}
| RPAR expression DOUBLE_DOT expression LPAR {
    Point *p = new Point(Point::from_polar($2, $4));
    $$ = p;
}
| TRANSLATE_BUILDIN RPAR point COMMA point LPAR {
  $$ = new Point($3->translate(*$5));
}
| ROTATE_BUILDIN RPAR point COMMA point COMMA REAL LPAR {
  $$ = new Point($3->rotate(*$5,$7));
}
;

path : path PATH_SEPARATOR point {
    $1->append(*$3);
    delete $3;
    $$ = $1;
}
| path PATH_SEPARATOR PLUS point {
    $1->append_relative(*$4);
    delete $4;
    $$ = $1;
}
| path PATH_SEPARATOR CYCLE {
    $1->append_cycle();
    $$ = $1;
}
| point PATH_SEPARATOR point {
    Path *c = new Path();
    c->append(*$1);
    c->append(*$3);
    delete $3;
    $$ = c;
}
| point PATH_SEPARATOR PLUS point {
    Path *c = new Path();
    c->append(*$1);
    c->append_relative(*$4);
    delete $4;
    $$ = c;
}
| point PATH_SEPARATOR CYCLE {
    Path *c = new Path();
    c->append(*$1);
    c->append_cycle();
    $$ = c;
}
;

command : DRAW_COMMAND path SEMICOLON {
    Command *c = new Command(DRAW, *$2);
    delete $2;
    $$ = c;
}
| FILL_COMMAND path SEMICOLON {
    Command *c = new Command(FILL, *$2);
    delete $2;
    $$ = c;
}
;

/*
variable: NAME EQ point SEMICOLON
| NAME EQ path
| NAME EQ image
;
 */

/*
image: IMG_START flow IMG_END
;
 */

/*
rotation : ROTATION RPAR REAL COMMA REAL COMMA REAL LPAR
 */

%%

int main(int argc, char ** argv) {
    Command::init_cairo(CAIRO_FORMAT_ARGB32, 200, 200);
    yyparse();
    Command::write_png_file(argv[1]);
    Command::close_cairo();

    return EXIT_SUCCESS;
}