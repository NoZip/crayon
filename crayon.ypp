%{
#include <iostream>

#include "error.hpp"

#include "point.hpp"
#include "path.hpp"

#include "environment.hpp"
#include "expression.hpp"
#include "inequation.hpp"

#include "instruction.hpp"
#include "command.hpp"
#include "variable_affectation.hpp"
#include "flow.hpp"
// #include "conditional.hpp"

#define YYLEX_PARAM &yylval, &yylloc

using std::string;
%}

%locations

// Types definitions

%union {
    float real;
    bool boolean;
    char* name;
    Point* point;
    Path* path;
    Expression* expression;
    Inequation* inequation;
    Instruction* instruction;
    Command *command;
    VariableAffectation* variable;
    Flow* flow;
    // Conditional* conditional;
    // While* while;
}

%token <real> REAL
%token <name> NAME

%type <expression> sexpression
%type <expression> expression
%type <inequation> inequation

%type <point> point
%type <path> path

%type <instruction> instruction
%type <command> command
%type <variable> variable
%type <flow> flow
%type <flow> block
// %type <conditional> conditional


// Operators and separators
%token SEMICOLON
%token EQ
%token RPAR LPAR
%token PLUS MINUS MUL DIV
%token EQUAL NEQUAL GT GTE LT LTE
%token NOT OR AND
%token COMMA DOUBLE_DOT
%token PATH_SEPARATOR CYCLE
%token DRAW_COMMAND FILL_COMMAND
%token TRANSLATE_BUILDIN
%token ROTATE_BUILDIN
%token LBRACE
%token RBRACE
%token CONDITIONALIF
%token CONDITIONALELSE
%token WHILE
%left PLUS MINUS
%left MUL DIV
%left UNARY

%{
#define yyerror(Msg) _yyerror(&yylloc, Msg)

void _yyerror(YYLTYPE *yylloc, const char *s) {
    fprintf(stderr, "ERROR %d:%d %s\n", yylloc->first_line, yylloc->first_column, s);
}

extern "C" {
    int yylex(YYSTYPE * yylval_param,YYLTYPE * yylloc_param);
}

Environment current_env;
%}

%%

image : flow {$1->execute(current_env);}
;

instruction : command SEMICOLON {$$ = $1;}
| variable SEMICOLON {$$ = $1;}
| block {$$ = $1;}
;

flow : flow instruction {$$ = $1; $$->append($2);}
| instruction {Flow *f = new Flow(); f->append($1); $$ = f;}
;

expression : NAME {$$ = new VariableExpression(string($1));}
| sexpression

// Computes mathematical expressions
sexpression : expression PLUS expression {$$ = new BinaryExpression(EXPR_PLUS, $1, $3);}
| expression MINUS expression {$$ = new BinaryExpression(EXPR_MINUS, $1, $3);}
| MINUS expression %prec UNARY {$$ = new UnaryExpression(EXPR_NEGATE, $2);}
| expression MUL expression {$$ = new BinaryExpression(EXPR_MUL, $1, $3);}
| expression DIV expression {$$ = new BinaryExpression(EXPR_DIV, $1, $3);}
| REAL {$$ = new ConstantExpression($1);}
| RPAR expression LPAR {$$ = $2;}
;

inequation : expression EQUAL expression {$$ = new BinaryInequation(INEQ_EQUAL, $1, $3);}
| expression NEQUAL expression {$$ = new BinaryInequation(INEQ_NEQUAL, $1, $3);}
| expression GT expression {$$ = new BinaryInequation(INEQ_GT, $1, $3);}
| expression GTE expression {$$ = new BinaryInequation(INEQ_GTE, $1, $3);}
| expression LT expression {$$ = new BinaryInequation(INEQ_LT, $1, $3);}
| expression LTE expression {$$ = new BinaryInequation(INEQ_LTE, $1, $3);}
| RPAR expression LPAR {$$ = $2;}
| NOT inequation {$$ = new UnaryInequation(INEQ_NOT, $2);}
| inequation AND inequation {$$ = new CompositeInequation(INEQ_AND, $1, $3);}
| inequation OR inequation {$$ = new CompositeInequation(INEQ_OR, $1, $3);}
| RPAR inequation LPAR {$$ = $2;} 
;


point : RPAR expression COMMA expression LPAR {
    Point *p = new Point($2, $4);
    $$ = p;
}
/*
| RPAR expression DOUBLE_DOT expression LPAR {
    Point *p = new Point(Point::from_polar($2, $4));
    $$ = p;
}
| NAME {
    Variable v = current_env->get_variable(string($1));
    if (v.type == VECTOR2D) {
        $$ = (Point*) v.value;
    }
    else {
        throw VariableError(string("La variable n'est pas un point\n");
    }
  }
| TRANSLATE_BUILDIN RPAR point COMMA point LPAR {
  $$ = new Point($3->translate(*$5));
}
| ROTATE_BUILDIN RPAR point COMMA point COMMA REAL LPAR {
  $$ = new Point($3->rotate(*$5,$7));
}
*/
;

path : path PATH_SEPARATOR point {
    $1->append(*$3);
    delete $3;
    $$ = $1;
}
| path PATH_SEPARATOR PLUS point {
    $1->append_relative(*$4);
    delete $4;
    $$ = $1;
}
| path PATH_SEPARATOR CYCLE {
    $1->append_cycle();
    $$ = $1;
}
| point PATH_SEPARATOR point {
    Path *c = new Path();
    c->append(*$1);
    c->append(*$3);
    delete $1;
    delete $3;
    $$ = c;
}
| point PATH_SEPARATOR PLUS point {
    Path *c = new Path();
    c->append(*$1);
    c->append_relative(*$4);
    delete $1;
    delete $4;
    $$ = c;
}
| point PATH_SEPARATOR CYCLE {
    Path *c = new Path();
    c->append(*$1);
    c->append_cycle();
    delete $1;
    $$ = c;
}
;

command : DRAW_COMMAND path {
    Command *c = new Command(DRAW, *$2);
    delete $2;
    $$ = c;
    // c->execute(*current_env);
}
/*
| DRAW_COMMAND NAME {
    Variable v = current_env->get_variable(string($2));

    if (v.type != PATH)
        throw "MOTHERFUCKING ERROR!";
    
    Path p = *((Path*) v.value);

    Command *c = new Command(DRAW, p);
    $$ = c;
    // c->execute(*current_env);
}
*/
| FILL_COMMAND path {
    Command *c = new Command(FILL, *$2);
    delete $2;
    $$ = c;
    // c->execute(*current_env);
}
/*
| FILL_COMMAND NAME {
    Variable v = current_env->get_variable(string($2));

    if (v.type != PATH)
        throw "MOTHERFUCKING ERROR!";
    
    Path p = *((Path*) v.value);

    Command *c = new Command(FILL, p);
    $$ = c;
    // c->execute(*current_env);
}
*/
;

variable: NAME EQ expression {
$$ = new VariableAffectation(string($1), SCALAR, $3);
}
// | NAME EQ point {current_env->set_variable(string($1), VECTOR2D, new Point(*$3)); delete $3;}
// | NAME EQ path {current_env->set_variable(string($1), PATH, new Path(*$3)); delete $3;}
// | NAME EQ image
;

block : LBRACE flow RBRACE {$$ = $2;}

/*
image: IMG_START flow IMG_END
;
 */

/*
rotation : ROTATION RPAR REAL COMMA REAL COMMA REAL LPAR

conditional : CONDITIONALIF RPAR inequation LPAR LBRACE flow RBRACE CONDITIONALELSE LBRACE flow RBRACE
;
*/

/*
while : WHILE RPAR inequation LPAR block
;
*/

%%

int main(int argc, char ** argv) {
    Command::init_cairo(CAIRO_FORMAT_ARGB32, 200, 200);
    yyparse();
    Command::write_png_file(argv[1]);
    Command::close_cairo();

    return EXIT_SUCCESS;
}
