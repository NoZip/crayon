%{
#include <string>

#include "point.hpp"
#include "path.hpp"

#include "environment.hpp"

#include "instruction.hpp"
#include "command.hpp"
#include "flow.hpp"

#define YYLEX_PARAM &yylval, &yylloc

using std::string;
%}

%locations

// Types definitions

%union {
    float real;
    bool boolean;
    char* name;
    Point* point;
    Path* path;
    Command *command;
    Flow* flow;
}

%token <real> REAL
%token <name> NAME

%type <real> expression
//%type <boolean> inequation

%type <point> point
%type <path> path

%type <command> command
%type <flow> flow


// Operators and separators
%token SEMICOLON
%token EQ
%token RPAR LPAR
%token PLUS MINUS MUL DIV
%token EQUAL NEQUAL GT GTE LT LTE
%token COMMA DOUBLE_DOT
%token PATH_SEPARATOR CYCLE
%token DRAW_COMMAND FILL_COMMAND
%token TRANSLATE_BUILDIN
%token ROTATE_BUILDIN

%left PLUS MINUS
%left MUL DIV
%left UNARY

%{
#define yyerror(Msg) _yyerror(&yylloc, Msg)

void _yyerror(YYLTYPE *yylloc, const char *s) {
    fprintf(stderr, "ERROR %d:%d %s\n", yylloc->first_line, yylloc->first_column, s);
}

extern "C" {
    int yylex(YYSTYPE * yylval_param,YYLTYPE * yylloc_param);
}

Environment *root_env = new Environment();
%}

%%

image : flow {}
;

flow : command flow {$2->append($1);}
| command {Flow *f = new Flow(); f->append($1); $$ = f;}
| variable  flow {$$ = $2;}
;

// Computes mathematical expressions
expression : expression PLUS expression {$$ = $1 + $3;}
| expression MINUS expression {$$ = $1 - $3;}
| MINUS expression %prec UNARY {$$ = -$2;}
| expression MUL expression {$$ = $1 * $3;}
| expression DIV expression {$$ = $1 / $3;}
| NAME {
    Variable v = root_env->get_variable(string($1));
    if (v.type == SCALAR) {
        $$ = *((float*) v.value);
    }
    else {
        throw "MOTHERFUCKING ERROR!";
    }
  }
| REAL {$$ = $1;}
;

/*
inequation : expression EQUAL expression {$$ = ($1 == $3);}
| expression NEQUAL expression {$$ = ($1 != $3);}
| expression GT expression {$$ = ($1 > $3);}
| expression GTE expression {$$ = ($1 >= $3);}
| expression LT expression {$$ = ($1 < $3);}
| expression LTE expression {$$ = ($1 <= $3);}
;
*/

point : RPAR expression COMMA expression LPAR {
    Point *p = new Point($2, $4);
    $$ = p;
}
| RPAR expression DOUBLE_DOT expression LPAR {
    Point *p = new Point(Point::from_polar($2, $4));
    $$ = p;
}
/*
| NAME {
    Variable v = root_env->get_variable(string($1));
    if (v.type == VECTOR2D) {
        $$ = (Point*) v.value;
    }
    else {
        throw "MOTHERFUCKING ERROR!";
    }
  }
*/
| TRANSLATE_BUILDIN RPAR point COMMA point LPAR {
  $$ = new Point($3->translate(*$5));
}
| ROTATE_BUILDIN RPAR point COMMA point COMMA REAL LPAR {
  $$ = new Point($3->rotate(*$5,$7));
}
;

path : path PATH_SEPARATOR point {
    $1->append(*$3);
    delete $3;
    $$ = $1;
}
| path PATH_SEPARATOR PLUS point {
    $1->append_relative(*$4);
    delete $4;
    $$ = $1;
}
| path PATH_SEPARATOR CYCLE {
    $1->append_cycle();
    $$ = $1;
}
| point PATH_SEPARATOR point {
    Path *c = new Path();
    c->append(*$1);
    c->append(*$3);
    delete $1;
    delete $3;
    $$ = c;
}
| point PATH_SEPARATOR PLUS point {
    Path *c = new Path();
    c->append(*$1);
    c->append_relative(*$4);
    delete $1;
    delete $4;
    $$ = c;
}
| point PATH_SEPARATOR CYCLE {
    Path *c = new Path();
    c->append(*$1);
    c->append_cycle();
    delete $1;
    $$ = c;
}
/*
| NAME {
    Variable v = root_env->get_variable(string($1));
    if (v.type == PATH) {
        $$ = (Path*) v.value;
    }
    else {
        throw "MOTHERFUCKING ERROR!";
    }
  }
*/
;

command : DRAW_COMMAND path SEMICOLON {
    Command *c = new Command(DRAW, *$2);
    delete $2;
    $$ = c;
    c->execute(root_env);
}
| FILL_COMMAND path SEMICOLON {
    Command *c = new Command(FILL, *$2);
    delete $2;
    $$ = c;
    c->execute(root_env);
}
;

variable: NAME EQ REAL SEMICOLON {root_env->set_variable(string($1), SCALAR, new float($3));}
| NAME EQ point SEMICOLON {root_env->set_variable(string($1), VECTOR2D, $3);}
| NAME EQ path SEMICOLON {root_env->set_variable(string($1), PATH, $3);}
// | NAME EQ image SEMICOLON
;

/*
image: IMG_START flow IMG_END
;
 */

/*
rotation : ROTATION RPAR REAL COMMA REAL COMMA REAL LPAR
 */

%%

int main(int argc, char ** argv) {
    Command::init_cairo(CAIRO_FORMAT_ARGB32, 200, 200);
    yyparse();
    Command::write_png_file(argv[1]);
    Command::close_cairo();

    return EXIT_SUCCESS;
}